{"version":3,"sources":["serviceWorker.js","component/Card.js","component/CardList.js","component/SearchBox.js","component/Scroll.js","component/ErrorBoundry.js","containers/App.js","index.js"],"names":["Boolean","window","location","hostname","match","Card","id","name","email","className","src","alt","CardList","robots","map","user","i","key","SearchBox","searchChange","type","placeholder","onChange","Scroll","props","style","overflowY","border","height","children","ErrorBoundry","state","hasError","error","info","this","setState","Component","App","onSearchChange","event","searchfield","target","value","console","log","fetch","then","response","json","users","filteredRobots","filter","robot","toLowerCase","includes","length","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"sMAYoBA,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2D,sCCFSC,EAbF,SAAC,GAAqB,IAApBC,EAAmB,EAAnBA,GAAGC,EAAgB,EAAhBA,KAAKC,EAAW,EAAXA,MAEtB,OACC,yBAAKC,UAAY,uDAChB,yBAAKC,IAAG,+BAA0BJ,EAA1B,YAAwCK,IAAI,WACpD,6BACC,4BAAKJ,GACL,2BAAIC,MCWOI,EAlBE,SAAC,GAAc,IAAbC,EAAY,EAAZA,OAClB,OACG,6BAEEA,EAAOC,KAAI,SAACC,EAAKC,GAClB,OACC,kBAAC,EAAD,CACCC,IAAKD,EACLV,GAAIO,EAAOG,GAAGV,GACdC,KAAMM,EAAOG,GAAGT,KAChBC,MAAOK,EAAOG,GAAGR,WARpB,MCIWU,EAPG,SAAC,GAAoB,IAAnBC,EAAkB,EAAlBA,aACnB,OACC,yBAAKV,UAAU,OACd,2BAAOA,UAAU,mCAAmCW,KAAK,SAASC,YAAY,eAAeC,SAAUH,MCK3FI,EARA,SAACC,GACf,OACE,yBAAKC,MAAO,CAACC,UAAY,SAASC,OAAO,kBAAkBC,OAAO,UAChEJ,EAAMK,WCeIC,G,wDAjBd,WAAYN,GAAO,IAAD,8BACjB,cAAMA,IACDO,MAAQ,CACZC,UAAW,GAHK,E,8DAMAC,EAAMC,GACvBC,KAAKC,SAAS,CAACJ,UAAW,M,+BAIzB,OAAGG,KAAKJ,MAAMC,SACN,8DAEDG,KAAKX,MAAMK,a,GAfMQ,cCoDZC,E,kDA7Cd,aAAc,IAAD,8BACZ,gBAmBDC,eAAiB,SAACC,GACjB,EAAKJ,SAAS,CAACK,YAAcD,EAAME,OAAOC,SAnB1C,EAAKZ,MAAQ,CAEZlB,OAAS,GACT4B,YAAY,IAEbG,QAAQC,IAAI,cAAc,KAPd,E,gEASO,IAAD,OAGlBC,MAAM,8CAA8CC,MAAK,SAAAC,GACxD,OAAOA,EAASC,UACdF,MAAK,SAAAG,GACP,EAAKd,SAAS,CAACvB,OAAQqC,OAExBN,QAAQC,IAAI,oBAAoB,O,+BAMxB,IAAD,EACsBV,KAAKJ,MAA3BlB,EADA,EACAA,OAAO4B,EADP,EACOA,YACRU,EAAiBtC,EAAOuC,QAAO,SAAAC,GACpC,OAAOA,EAAM9C,KAAK+C,cAAcC,SAASd,EAAYa,kBAGtD,OADAV,QAAQC,IAAI,SAAS,KACbhC,EAAO2C,OAGb,yBAAK/C,UAAU,MACd,wBAAIA,UAAU,MAAd,cACA,kBAAC,EAAD,CAAWU,aAAcgB,KAAKI,iBAC9B,kBAAC,EAAD,KACC,kBAAC,EAAD,KACC,kBAAC,EAAD,CAAU1B,OAAQsC,OAPtB,2C,GA/Bed,aCDlBoB,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SPwHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBjB,MAAK,SAAAkB,GACJA,EAAaC,gBAEdC,OAAM,SAAAlC,GACLW,QAAQX,MAAMA,EAAMmC,a","file":"static/js/main.89e86369.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';//React must br when we usnig JSX\r\n\r\n\r\nconst Card = ({id,name,email}) => {\r\n\t//const {id,name,email} = props;//we can do it in the parameter\r\n\treturn(//we return just one thing ===> div just one div contains all we need\r\n\t\t<div className = 'tc bg-light-green dib br3 pa3 ma2 grow bw2 shadow-5'>\r\n\t\t\t<img src={`https://robohash.org/${id}?200x200`} alt='robots'/>\r\n\t\t\t<div>\r\n\t\t\t\t<h2>{name}</h2>\r\n\t\t\t\t<p>{email}</p>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t);\r\n}\r\n\r\nexport default Card;\r\n/*\r\ntc : text center \r\nbg-light-green font-style\r\ndib :  \r\nbr3 : border\r\npa3 : padding \r\nma2 : margin\r\ngrow : for annimation\r\nbw2 shadow-5 : add shadow \r\n*/\r\n","import React from 'react';\r\nimport Card from './Card';\r\n\r\nconst CardList = ({robots}) => {//its pure function receive something and return something\r\n\treturn(\r\n\t  \t<div>\r\n\t  \t\t{\r\n\t  \t\t\trobots.map((user,i) =>{\r\n\t\t\t\t\treturn (\r\n\t\t\t\t\t\t<Card \r\n\t\t\t\t\t\t\tkey={i} \r\n\t\t\t\t\t\t\tid={robots[i].id} \r\n\t\t\t\t\t\t\tname={robots[i].name} \r\n\t\t\t\t\t\t\temail={robots[i].email}\r\n\t\t\t\t\t\t/>\r\n\t\t\t\t\t);\r\n\t\t\t\t})\r\n\t  \t\t};\r\n\t    </div>\r\n\t);\r\n}\r\nexport default CardList;\r\n\r\n\r\n/*\r\nwe this we return everytime div div so in total project we have a lot of div but we can return multiple element without div with\r\nimport React, { Fragment } from \"react\";\r\n  return (\r\n    <Fragment>\r\n      <h1>{props.title}</h1>\r\n      <p>{props.subtitle}</p>\r\n    </Fragment>\r\n  )\r\n*/\r\n\r\n/*\r\n- when we doing a loop like map we must give it a unique key because if one of cards was deleted react will not know any element \r\nwill delete and will change the entire DOM , so if it has a key prop React will remove easy element with key \r\n- so when we doing a loop we have to give it a unique key\r\n*/","import React from 'react';\r\n\r\nconst SearchBox = ({searchChange}) => {\r\n\treturn(\r\n\t\t<div className='pa2'>\r\n\t\t\t<input className='pa3 ba b--green bg-lightest-blue' type='search' placeholder='search robot' onChange={searchChange}/>\r\n\t\t</div>\r\n\t\t);\r\n}\r\nexport default SearchBox;","import React from 'react';\r\n\r\nconst Scroll = (props) => {\r\n\treturn(\r\n\t\t\t<div style={{overflowY : 'scroll',border:'3px solid black',height:'800px'}}>\r\n\t\t\t\t{props.children}\r\n\t\t\t</div>\r\n\t\t);\r\n}\r\n\r\nexport default Scroll;\r\n\r\n/*\r\n- Scroll its a wrap component : render what inside of him\r\n- Scroll can use children as a way to render its children ==> props.children\r\n- we can use this props.children we can create component that wrap other Components  \r\n*/","import React, { Component } from 'react';\r\n\r\nclass ErrorBoundry extends Component{\r\n\tconstructor(props){//to allaow acces to this.props\r\n\t\tsuper(props);\r\n\t\tthis.state = {\r\n\t\t\thasError : false\r\n\t\t}\r\n\t}\r\n\tcomponentDidCatch(error,info){\r\n\t\tthis.setState({hasError : true});\r\n\t}\r\n\r\n\trender(){\r\n\t\t\tif(this.state.hasError){\r\n\t\t\t\treturn <h1>Ooooooops, That is not good!!!</h1>\r\n\t\t\t}\r\n\t\t\treturn this.props.children;\r\n\t}\r\n}\r\nexport default ErrorBoundry;\r\n\r\n/*\r\n- exemple : we are usig ErrorBoundry class to catch if there is an error to display CardList\r\n- and to chnge the state of hasError variable we use componentDidCatch(error,info) method : \r\n\t- its like tha try catch block in js if nything errors out it will run this lifecycle hook and \r\n- and finally import ErrorBoundry class in App.js\r\n- errorboundry are reallu useful when we put our app into production where we don't have detaild logs of whats error we have.\r\n- we want our users just see our message error boundry\r\n*/","import React,{ Component } from 'react';\r\nimport CardList from '../component/CardList';//the parent of Card it contains a list of card \r\n/*import { robots } from './robots';*///{ robots } because its export without default so it can export alot of thing => se we select what we want\r\nimport SearchBox from '../component/SearchBox';\r\nimport Scroll from '../component/Scroll';//to make the searchBox fix and data still load when scrolling\r\nimport './App.css';\r\nimport ErrorBoundry from '../component/ErrorBoundry';//gestionne d'erreur\r\n\r\nclass App extends Component{\r\n\tconstructor(){\r\n\t\tsuper();\r\n\t\tthis.state = {\r\n\t\t\t//robots : robots,\r\n\t\t\trobots : [],\r\n\t\t\tsearchfield:''\r\n\t\t}\r\n\t\tconsole.log('constructor','1');\r\n\t}\r\n\tcomponentDidMount(){\r\n\t\t//make HTTP request and fetch receive responce\r\n\t\t//fetch allows us to make request on server and return for us a list of users\r\n\t\tfetch('https://jsonplaceholder.typicode.com/users').then(response => {\r\n\t\t\treturn response.json();\r\n\t\t}).then(users => {\r\n\t\t\tthis.setState({robots: users});\r\n\t\t})\r\n\t\tconsole.log('componentDidMount','2');\r\n\t}\r\n\r\n\tonSearchChange = (event) => {//change it to arrow function to make this refers to App and not to input\r\n\t\tthis.setState({searchfield : event.target.value});//give value in searchBox\r\n\t}\r\n\trender(){\r\n\t\tconst {robots,searchfield} = this.state;\r\n\t\tconst filteredRobots = robots.filter(robot =>{\r\n\t\t\treturn robot.name.toLowerCase().includes(searchfield.toLowerCase());\r\n\t\t\t})\r\n\t\tconsole.log('render','3');\r\n\t\treturn !robots.length?//if we have a lot of users and we take a lot of time to get it from the servers \r\n\t\t\t<h1>Loading</h1>:\r\n\t\t\t(\r\n\t\t\t\t<div className='tc'>\r\n\t\t\t\t\t<h1 className='f2'>RoboFriend</h1>\r\n\t\t\t\t\t<SearchBox searchChange={this.onSearchChange}/>\r\n\t\t\t\t\t<Scroll>\r\n\t\t\t\t\t\t<ErrorBoundry>\r\n\t\t\t\t\t\t\t<CardList robots={filteredRobots}/>\r\n\t\t\t\t\t\t</ErrorBoundry>\r\n\t\t\t\t\t</Scroll>\t\r\n\t\t\t\t</div>\t\r\n\t\t\t)\r\n\t\t}\r\n\t}\r\n\r\nexport default App; \r\n\r\n/*\r\n- to make our website responsive we need searchBox communicate with CardList and also CardList communicate with SearchBox \r\n- we have the perent is : App and he have two children : SearchBox and CardList \r\n- so to SearchBox communicate with CardList we must pass over the father(App) and Then communicate with CardList\r\n- to do this React offer : \r\n\tState : - its simply means the description of our app\r\n\t\t\t- is simply an object that describ my application \r\n\t\t\t- able to change and affect our app\r\n\t\t\t- usuelly live in the parent component(passes \"state\" to deffrent component)\r\n- and wich describ our application is the robot and the SearchBox  \r\n- so we're able to change what in the searchBox and we able to change what robot means => what gets displayed\r\n- props are simply things that come out of \"state\"\r\n- so a parent feeds \"state\" into a child componenet and as soon as a child(component) component receive the \"state\" its property\r\nthat child can never change this property. the parent just tells it what the \"state\" is ad the child receives it as a \"robots\" \r\n- to use state we must work with class\r\n- it triggers the event , the parents says \"oh, run this funciuon\" (onsearchChange()) now we have the value in searchBox we can\r\ncommunicat directly with CardList \r\n\r\n<********************-the entire process: ***************************>\r\n1)- we have our app component that has two states \"robot\" and \"searchfield\" and because App own the state any component \r\nhas \"state\" uses the \"class\" syntax so they can use  \"constructor\" function to create \"this.state\" and this \"state\" is what\r\nchange in an app => it's whats describes the app\r\n2)- the virtuel DOM is just an object that collect this entire state and React uses this state to render and pass them down\r\nas props to these components\r\n3)- these component are just pure functions can just render \r\n4)- always know that the app is going to look  the same because they are just pure function \r\n5)- the App can pass down things such as props, so we passed down \"onSearchChange\" to the searchBox \r\n6)- and the searchBox every time there is an \"onChange\" on the input it let the app konw,\"hey, there was a change run this function\"\r\n7)- it run the function with the event and update the state of the \"searchfield\" to whatever we type \r\n8)- with the information we have from the searchBox we can now communicate to the CardList and tell it \"filter the \r\nrobots state and to now have only what include in the searchfield\"\r\n9)- and we passed filterRobots to CardList  \r\n\r\n<******************************** make app realistic and get robots data from a server ***************************************>\r\n- App.js has state : a piece of data tha describ our app\r\n- and because they have state we call them : smart component (must have class syntax)\r\n-state become : this.state = {\r\n\t\t\t\t\trobots : [],\r\n\t\t\t\t\tsearchfield:''\r\n\t\t\t\t}==> i asked for users from somewhere over the internet\r\n- React has also something call lifecycle method or lifecycle hooks its method come with react(like : constructor,render) because what \r\nthey do is,if we run these ,it will automatically trigger when this app gets loaded on the web site\r\n- Each component has several “lifecycle methods” that you can override to run code at particular times in the process.\r\n\t- Mounting : when we click refresh the app component get mounted in root element(document.getElemnetById('root'))\r\n\t\t- replace document containte by our containte\r\n\t\t- is the startup of the app \r\n\t\t- its mount things in order :\r\n\t\t\t- constructor() : in React constructors are only used for two purposes:\r\n\t\t\t\t- Initializing local state by assigning an object to this.state.\r\n\t\t\t\t- Binding event handler methods to an instance.\r\n\t\t\t- static getDerivedStateFromProps() : is invoked right before calling the render method, both on the initial mount and on \r\n\t\t\t\tsubsequent updates. It should return an object to update the state, or null to update nothing.\r\n\t\t\t- render() : method is the only required method in a class component.\r\n\t\t\t\t- When called, it should examine this.props and this.state and return one of the following types:\r\n\t\t\t\t\t- React elements. Typically created via JSX. For example, <div />\r\n\t\t\t\t\t- Arrays and fragments. Let you return multiple elements from render. See the documentation on fragments.\r\n\t\t\t\t\t- Portals. Let you render children into a different DOM subtree. See the documentation on portals for more details.\r\n\t\t\t\t\t- String and numbers. These are rendered as text nodes in the DOM.\r\n\t\t\t\t\t- Booleans or null. Render nothing. (Mostly exists to support return test && <Child /> pattern, where test is boolean.)\r\n\t\t\t- componentDidMount() : is invoked immediately after a component is mounted (inserted into the tree).\r\n\t- Updating : An update can be caused by changes to props or state. These methods are called in the following order when a component \r\n\tis being re-rendered:\r\n\t\t- static getDerivedStateFromProps() :  is invoked right before calling the render method, both on the initial mount and on subsequent \r\n\t\t\tupdates. It should return an object to update the state, or null to update nothing.\r\n\t\t- shouldComponentUpdate() :to let React know if a component’s output is not affected by the current change in state or props. \r\n\t\t- render()\r\n\t\t- getSnapshotBeforeUpdate() :  is invoked right before the most recently rendered output is committed to e.g. the DOM. It enables \r\n\t\t\tyour component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value \r\n\t\t\treturned by this lifecycle will be passed as a parameter to componentDidUpdate().\r\n\t\t- componentDidUpdate() : is invoked immediately after updating occurs. This method is not called for the initial render.\r\n\t- Unmounting : This method is called when a component is being removed from the DOM:\r\n\t\t- componentWillUnmount() : is invoked immediately before a component is unmounted and destroyed. Perform any necessary cleanup in \r\n\t\t\tthis method, such as invalidating timers, canceling network requests, or cleaning up any subscriptions that were created \r\n\t\t\tin componentDidMount().\r\n- these aare called \"lifecycle hooks\"  because they get run every time a component does something and it comes with react, so we can\r\nput them in our class class componenet and they will automatically get trigerred(we don't have worry about calling them)\r\n\r\n- As soon robots and searchfield changes React tickless down All this information as \"props\" to all these component and magically \r\ncreates our view for us ==> that's why React so powerfull it's a view layer , it's take care of manipulating the DOM and all we tell \r\nit's \"hey what the state\" ==> it's a super app and these component are now reusable \r\n\r\n<****************** add errorboundry **************************************>\r\n- import ErrorBoundry class\r\n- get it before the CardList for reason that if something goes on with the CardList we want to have some sort of a graceful exit boundry\r\n- so with this error boundry, if anything in the CardList fails it's going to catch it and display our error msg \r\n\r\n\r\n\r\n\r\n*/\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport 'tachyons';\r\nimport App from './containers/App';//the father of all our component (we make a tree with childreen)\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n  \t\t<App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}